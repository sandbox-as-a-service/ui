# Copilot Instructions for sandbox-as-a-service/ui

High-signal guidance for GitHub Copilot in this component library.

## Repository Context
- Purpose: Central, reusable UI primitives for the Sandbox as a Service ecosystem.
- Tech stack: TypeScript, Tailwind CSS utilities, shadcn CLI–generated primitives (do not hand-roll patterns already scaffolded by the CLI).
- Styling paradigm: Utility-first (Tailwind) with variant helpers (e.g. class-variance-authority if present).
- Distribution: Consumed internally; focus on consistency and accessibility.

## Setup & Package Management
- Package manager: pnpm (pinned via the `packageManager` field in `package.json`).
- Use Corepack to ensure correct version:
  ```
  corepack enable
  corepack use pnpm
  ```
- All commands must use pnpm: e.g. `pnpm install`, `pnpm build-ui`, `pnpm dev`.
- Do NOT use npm, yarn, or bun for installs or scripts.
- Only commit `pnpm-lock.yaml`. Do NOT add `package-lock.json` or `yarn.lock`.
- When adding dependencies: `pnpm add <pkg>` (or `-D` for dev dependencies).

## Core Principles
1. Accessibility first: Correct roles, labels, focus states, keyboard interactions (Tab, Shift+Tab, Enter/Space, Escape, Arrow keys where applicable).
2. Type safety: Prefer explicit exported interfaces/types; avoid `any`.
3. Composition over complexity: Small primitives and composable props instead of monolithic components.
4. Predictable styling: Tailwind utilities + existing variant utilities; avoid inline style objects unless dynamically computed and necessary.
5. Purity: Keep components side-effect free; side effects reside in hooks.
6. Generated patterns: Follow shadcn CLI conventions; do not diverge without strong justification.
7. Named exports only: No default exports.
8. Minimal assumptions: Avoid embedding domain/business logic.

## File & Directory Conventions
Actual structure favors lower-case, dash-delimited file names for primitives (as generated by shadcn CLI). Example (illustrative, adapt to existing layout):
```
src/
  components/
    accordion.tsx
    badge.tsx
    dropdown-menu.tsx
    input.tsx
    // ...
  lib/
    utils.ts        # cn(), helper utilities
  index.ts          # Re-exports named primitives
```
Guidelines:
- Use lower-case, dash-delimited filenames (e.g. `toggle-group.tsx`).
- Each primitive file contains its logic + exports.
- Shared helpers live under `lib/` (or existing utility directory).
- Avoid creating nested folders unless a component genuinely needs multiple tightly-coupled files (rare).

## Component Authoring Pattern
- Export only named symbols (no `export default`).
- Provide a prop interface: `export interface XProps { ... }`.
- Prefer extending relevant intrinsic attribute interfaces (e.g. `React.ButtonHTMLAttributes<HTMLButtonElement>`).
- Use `React.forwardRef` for focusable / externally controlled DOM elements.
- Only add `displayName` when `forwardRef` or polymorphism would otherwise make the inferred name unclear.
- Accept `className` and merge with internal classes (`cn()`).
- Support variants via existing variant utility (if configured) instead of manual branching when possible.
- Keep uncontrolled vs. controlled behavior explicit (e.g. `value` + `onValueChange` vs. internal state) only when required.

### Example Skeleton (Named Export Only)
```tsx
import * as React from 'react';
import { cn } from '../lib/utils';
// import { buttonVariants } from './button-variants'; // if variant util exists

export interface ButtonProps extends React.ButtonHTMLAttributes<HTMLButtonElement> {
  variant?: 'default' | 'destructive' | 'outline' | 'secondary' | 'ghost' | 'link';
  size?: 'default' | 'sm' | 'lg' | 'icon';
  asChild?: boolean;
}

export const Button = React.forwardRef<HTMLButtonElement, ButtonProps>(
  ({ className, variant = 'default', size = 'default', asChild = false, ...props }, ref) => {
    const Comp = asChild ? Slot : 'button'; // Only if Slot pattern is already established
    return (
      <Comp
        ref={ref}
        className={cn(
          // buttonVariants({ variant, size }),
          // Fallback utility classes if variant helper not used:
          'inline-flex items-center justify-center rounded-md text-sm font-medium transition-colors focus-visible:outline-none focus-visible:ring disabled:opacity-50 disabled:pointer-events-none',
          className
        )}
        data-variant={variant}
        data-size={size}
        {...props}
      />
    );
  }
);
// Only include when beneficial for debugging / story grouping:
// Button.displayName = 'Button';
```

## Accessibility Checklist
For every interactive primitive:
- Provides accessible name (text, `aria-label`, or `aria-labelledby`).
- Keyboard operable (Enter/Space activation, arrow navigation for composite widgets).
- Focus visible outline consistent and not removed.
- Correct ARIA attributes for stateful widgets (`aria-expanded`, `aria-selected`, `aria-checked`, etc.).
- Proper labeling of groups/relationships (`role="group"`, `aria-controls`, `aria-describedby`).
- No reliance solely on color for meaning.
- Sufficient color contrast (WCAG AA).

## Tailwind & Styling
- Order utilities (suggested): layout → box model (spacing, sizing) → typography → visuals (color, background, border) → interaction/state (focus, hover, data-* conditions) → animation.
- Prefer semantic variant utilities already established over ad-hoc conditionals.
- Avoid introducing hard-coded colors if tokens / existing Tailwind config classes cover the case.
- Keep responsive/dark variants minimal and purposeful.

## Export Pattern
- All primitives are named exports from their defining file.
- `src/index.ts` (or equivalent) re-exports each primitive:
  ```ts
  export * from './components/accordion';
  export * from './components/badge';
  // ...
  ```
- No default exports; ensures consistent tree-shaking and auto-import behavior.

## Utilities
- Centralize reusable helpers (e.g. `cn`, `composeRefs`) in `lib/`.
- Avoid duplicating logic across primitives.
- Do not introduce opinionated state management helpers inside UI layer.

## Performance
- Avoid unnecessary re-renders: do not create new object/array literals inside JSX when static.
- Memoize expensive derived values with `useMemo` only when profiling indicates a benefit.
- Defer non-critical side effects to `useEffect`.
- Keep component surface lean; split rare heavy logic if it grows.

## Positive Copilot Behaviors
1. Generates a new primitive mirroring existing naming/style/export conventions.
2. Adds ARIA attributes and keyboard handlers aligned with WAI-ARIA patterns.
3. Reuses `cn()` and variant helpers instead of duplicating class strings.

## Negative Copilot Behaviors (Reject)
1. Introducing default exports.
2. Adding unsupported package manager commands (npm/yarn).
3. Creating speculative folders (`card/`, `button/`) not present in current structure.
4. Inlining large style objects instead of Tailwind utilities.
5. Emitting `any` or omitting prop typing.

## Documentation Pattern
- Keep top-of-file comments concise (only when clarifying non-obvious behavior).
- Collocate minor helper types with the component; extract only when reused elsewhere.
- Avoid verbose internal comments for straightforward Tailwind class usage.

## Migration / Deprecation
- Add `@deprecated` JSDoc with replacement guidance when superseding a primitive.
- Prefer additive changes; remove deprecated APIs only alongside a coordinated release (see Release section).

## Security Considerations
- Do not introduce `dangerouslySetInnerHTML` unless required; if used, document sanitization expectations.
- Do not widen surface for script injection via unsafe prop spreading onto arbitrary elements.

## Release & Versioning
- Semantic intent retained (conceptually MAJOR.MINOR.PATCH), but releases are triggered manually through a workflow dispatch choosing the version (no Git tags are used).
- Ensure the chosen version aligns with nature of changes (breaking vs. additive vs. fix).
- Update `package.json` version via the release workflow process; do not rely on local tagging.

## Publishing
- Do not import from build artifacts inside source.
- Preserve stable public exports; avoid churn in re-export ordering that causes noisy diffs.

## Checklist for a New Primitive
- [ ] Named export only
- [ ] Props interface exported
- [ ] `className` merged via `cn`
- [ ] Accessibility (roles, labels, keyboard)
- [ ] Variants integrated (if applicable)
- [ ] No default export
- [ ] No package manager misuse (pnpm only)
- [ ] Optional displayName only if needed

## When Unsure
Prefer smallest, most explicit primitive. Avoid speculative abstraction. Align with shadcn CLI output style before extending.

---

These instructions steer Copilot toward producing accessible, type-safe, pnpm-aligned, shadcn-style primitives using named exports and the repository’s established conventions.