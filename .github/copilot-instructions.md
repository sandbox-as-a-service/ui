# Copilot Instructions for sandbox-as-a-service/ui

High-signal guidance for GitHub Copilot in this component library.

## Repository Context

- Purpose: Central, reusable UI primitives for the Sandbox as a Service ecosystem.
- Tech stack: TypeScript, Tailwind CSS utilities, shadcn CLI–generated primitives (do not hand-roll patterns already scaffolded by the CLI).
- Styling paradigm: Utility-first (Tailwind) with variant helpers (e.g. class-variance-authority if present).
- Distribution: Consumed internally; focus on consistency and accessibility.

## Setup & Package Management

- The repo uses `.gitbub/workflow/copilot-setup-steps.yml` to set up the environement.
- The said workflow sets up:
  - node v22
  - pnpm
  - runs pnpm install
- If for some reason you dont have pnpm installed, use the instructions below to set it up.
- Use Corepack to ensure correct version:
  ```
  corepack enable
  corepack use pnpm
  ```
- All commands must use pnpm: e.g. `pnpm install`, `pnpm build-ui`, `pnpm dev`.
- Do NOT use npm, yarn, or bun for installs or scripts.
- Only commit `pnpm-lock.yaml`. Do NOT add `package-lock.json` or `yarn.lock`.
- When adding dependencies: `pnpm add <pkg>` (or `-D` for dev dependencies).

## Core Principles

1. Accessibility first: Correct roles, labels, focus states, keyboard interactions (Tab, Shift+Tab, Enter/Space, Escape, Arrow keys where applicable).
2. Type safety: Prefer explicit exported interfaces/types; avoid `any`.
3. Composition over complexity: Small primitives and composable props instead of monolithic components.
4. Predictable styling: Tailwind utilities + existing variant utilities; avoid inline style objects unless dynamically computed and necessary.
5. Purity: Keep components side-effect free; side effects reside in hooks.
6. Generated patterns: Follow shadcn CLI conventions; do not diverge without strong justification.
7. Named exports only: No default exports.
8. Minimal assumptions: Avoid embedding domain/business logic.

## File & Directory Conventions

Actual structure favors lower-case, dash-delimited file names for primitives (as generated by shadcn CLI). Example (illustrative, adapt to existing layout):

```
src/
  components/
    accordion.tsx
    badge.tsx
    dropdown-menu.tsx
    input.tsx
    // ...
  lib/
    utils.ts        # cn(), helper utilities
  index.ts          # Re-exports named primitives
```

Guidelines:

- Use lower-case, dash-delimited filenames (e.g. `toggle-group.tsx`).
- Do not use alias like `@/components/ui/button` for imports, instead, use relative paths.
- Each primitive file contains its logic + exports.
- Shared helpers live under `lib/` (or existing utility directory).
- Avoid creating nested folders unless a component genuinely needs multiple tightly-coupled files (rare).

## Component Authoring Pattern

- Use shadcn CLI to create new components. e.g. pnpm dlx shadcn@latest add alert.
- Do not edit the generated code when using shadcn CLI.
- When a new shadcn component is generated, add it to the index barrel file located at src/components/ui/index.ts

### Example Skeleton (Named Export Only)

```tsx
import * as React from "react";
import { cn } from "../lib/utils";
// import { buttonVariants } from './button-variants'; // if variant util exists

export interface ButtonProps
  extends React.ButtonHTMLAttributes<HTMLButtonElement> {
  variant?:
    | "default"
    | "destructive"
    | "outline"
    | "secondary"
    | "ghost"
    | "link";
  size?: "default" | "sm" | "lg" | "icon";
  asChild?: boolean;
}

export const Button = React.forwardRef<HTMLButtonElement, ButtonProps>(
  (
    {
      className,
      variant = "default",
      size = "default",
      asChild = false,
      ...props
    },
    ref
  ) => {
    const Comp = asChild ? Slot : "button"; // Only if Slot pattern is already established
    return (
      <Comp
        ref={ref}
        className={cn(
          // buttonVariants({ variant, size }),
          // Fallback utility classes if variant helper not used:
          "inline-flex items-center justify-center rounded-md text-sm font-medium transition-colors focus-visible:outline-none focus-visible:ring disabled:opacity-50 disabled:pointer-events-none",
          className
        )}
        data-variant={variant}
        data-size={size}
        {...props}
      />
    );
  }
);
// Only include when beneficial for debugging / story grouping:
// Button.displayName = 'Button';
```

## Accessibility Checklist

For every interactive primitive:

- Provides accessible name (text, `aria-label`, or `aria-labelledby`).
- Keyboard operable (Enter/Space activation, arrow navigation for composite widgets).
- Focus visible outline consistent and not removed.
- Correct ARIA attributes for stateful widgets (`aria-expanded`, `aria-selected`, `aria-checked`, etc.).
- Proper labeling of groups/relationships (`role="group"`, `aria-controls`, `aria-describedby`).
- No reliance solely on color for meaning.
- Sufficient color contrast (WCAG AA).

## Tailwind & Styling

- Order utilities (suggested): layout → box model (spacing, sizing) → typography → visuals (color, background, border) → interaction/state (focus, hover, data-\* conditions) → animation.
- Prefer semantic variant utilities already established over ad-hoc conditionals.
- Avoid introducing hard-coded colors if tokens / existing Tailwind config classes cover the case.
- Keep responsive/dark variants minimal and purposeful.

## Export Pattern

- All primitives are named exports from their defining file.
- `src/components/ui/index.ts` re-exports each primitive:
  ```ts
  export * from "./components/ui/accordion";
  export * from "./components/ui/badge";
  // ...
  ```
- No default exports; ensures consistent tree-shaking and auto-import behavior.

## Utilities

- Centralize reusable helpers (e.g. `cn`, `composeRefs`) in `lib/`.
- Avoid duplicating logic across primitives.
- Do not introduce opinionated state management helpers inside UI layer.

## Performance

- Avoid unnecessary re-renders: do not create new object/array literals inside JSX when static.
- Memoize expensive derived values with `useMemo` only when profiling indicates a benefit.
- Defer non-critical side effects to `useEffect`.
- Keep component surface lean; split rare heavy logic if it grows.

## Documentation Pattern

- Keep top-of-file comments concise (only when clarifying non-obvious behavior).
- Collocate minor helper types with the component; extract only when reused elsewhere.
- Avoid verbose internal comments for straightforward Tailwind class usage.

## Migration / Deprecation

- Add `@deprecated` JSDoc with replacement guidance when superseding a primitive.
- Prefer additive changes; remove deprecated APIs only alongside a coordinated release (see Release section).

## Security Considerations

- Do not introduce `dangerouslySetInnerHTML` unless required; if used, document sanitization expectations.
- Do not widen surface for script injection via unsafe prop spreading onto arbitrary elements.

## Release & Versioning

- Semantic intent retained (conceptually MAJOR.MINOR.PATCH), but releases are triggered manually through a workflow dispatch choosing the version (no Git tags are used).
- Ensure the chosen version aligns with nature of changes (breaking vs. additive vs. fix).
- Update `package.json` version via the release workflow process; do not rely on local tagging.
- See `.github/workflows/release.yml`

## Checklist for a New Primitive

- [ ] Use shadcn/ui CLI
- [ ] Named export only
- [ ] Props interface exported
- [ ] `className` merged via `cn`
- [ ] Accessibility (roles, labels, keyboard)
- [ ] No default export
- [ ] No package manager misuse (pnpm only)
- [ ] Optional displayName only if needed

## When Unsure

Prefer smallest, most explicit primitive. Avoid speculative abstraction. Align with shadcn CLI output style before extending.
